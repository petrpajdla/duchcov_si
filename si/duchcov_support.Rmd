---
title: "Duchcov hoard: Supplementary information"
author: "Alžběta Danielisová, Petr Pajdla"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    theme: spacelab
    highlight: tango
    number_sections: no
    toc: yes
    toc_depth: 4
    toc_float: yes
    fig.caption: true
bibliography: duchcov_references.bib
csl: journal-of-archaeological-science.csl
---

# Introduction

The purpose of this supplementary file is to reproduce data analysis
of artefact compositions and isotopic signals of objects from the
Duchcov hoard from the article *Exceptional ritual or a production deposit? The Duchcov hoard (Bohemia) as a proxy to ´Celtic migrations´ in the 4th century BC*.

`R` version 3.6.3 was used [@rct2020] to run the analysis.
Following `R` packages are used:
`tidyverse` family of packages [@wickham2019],
`ggforce` [@pedersen2019],
`ggbiplot` [@vu2011],
`ggridges` [@wilke2020],
`cluster` [@maechler2019],
`pdist` [@wong2013],
`StatMatch` [@dorazio2019],
`MASS` [@venables2002],
`cowplot` [@wilke2019],
`corrplot` [@corrplot2017],
`knitr` [@knitr], `DT` [@DT], `bookdown` [@bookdown], 
`grid` [@rct2020], `gridExtra` [@gridE], `here`[@here].

```{r setup}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.align = "center")
set.seed(42)
```

```{r packages, message=FALSE}
library(ggforce)
library(tidyverse)
```

```{r data}
duchcov <- read_csv(here::here("data", "duchcov.csv"))
```

# Composition analysis

```{r composition}
composition <- duchcov %>%
  select(Li:Bi) %>%
  as.matrix()
rownames(composition) <- duchcov$id

# elements selected for PCA and further analyses
elements <- c("Co", "Ni", "Zn", "As", "Ag", "Sb", "Pb")

DT::datatable(composition[, elements], caption = "Compositions table")
```

Only `r paste(elements, sep = ", ")` element compositions of `r nrow(composition)`
analyzed artefacts from Duchcov hoard were used for the analyses.

```{r corrplot}
corrplot::corrplot(cor(composition[, elements]),
                   type = "upper", diag = FALSE,
                   order = "hclust", method = "pie")
```

```{r pca}
# values are scaled to mean 0 and sd 1
composition_biplot <- scale(composition[, elements])
# solve overplotting in variable names on a biplot
colnames(composition_biplot)[4] <- "\nAs"
colnames(composition_biplot)[2] <- "\nNi"

pc_comp <- prcomp(composition_biplot)

# First 5 PCs are used in subsequent analysis to retain close to 95% of explained variance
summary(pc_comp)
```

```{r biplot, fig.cap="Biplot"}
# ggbiplot::ggbiplot(pc_comp)
```

```{r}
rm(list = c("composition_biplot"))
```


## Grouping in the compositions

*Elbow* method and silhouette method are used to determine number of clusters in the dataset.

```{r screeplot, fig.align = 'center', fig.cap="Scree plot"}
plot_scree_clusters <- function(x) {
  wss <- 0
  max_i <- (nrow(x) - 1)/4
  for (i in 1:max_i) {
    km.model <- kmeans(x, centers = i, nstart = 20)
    wss[i] <- km.model$tot.withinss
  }
  plot(1:max_i, wss, type = "b",
       xlab = "Number of Clusters",
       ylab = "Within groups sum of squares")
}

plot_scree_clusters(pc_comp$x[, 1:5])
```

```{r silhouette, fig.align = 'center', fig.cap="Silhouettes"}
plot_sil_width <- function(x) {
  sw <- 0
  max_i <- (nrow(x) - 1)/4
  for (i in 2:max_i) {
    km.model <- cluster::pam(x = pc_comp$x, k = i)
    sw[i] <- km.model$silinfo$avg.width
  }
  sw <- sw[-1]
  plot(2:max_i, sw, type = "b",
       xlab = "Number of Clusters",
       ylab = "Average silhouette width")
}

plot_sil_width(pc_comp$x[, 1:5])
```


```{r kmeans}
# ------------------------------------------------------------------------------
# please note: to avoid confusion in changes in k-means cluster numbers/colors
# the cluster assignment was hardcoded in a csv file 'clusters.csv'
# ------------------------------------------------------------------------------
# cluster <- tibble(kmeans = kmeans(pc_comp$x[, 1:5], centers = 4, nstart = 50)$cluster) %>% 
#   mutate(kmeans = as_factor(kmeans))
# write_csv(cluster), "../data/clusters.csv")
cluster <- read_csv(here::here("data", "clusters.csv")) %>%
  mutate(kmeans = factor(kmeans))
```

```{r km-pca, fig.cap="K-means clusters in PCA space"}
ggplot(as_tibble(pc_comp$x), aes(PC1, PC2, fill = cluster$kmeans)) +
  geom_mark_hull(aes(color = cluster$kmeans), expand = unit(2.4, "mm")) +
  geom_point(aes(shape = cluster$kmeans, color = cluster$kmeans)) +
  scale_fill_brewer(palette = "Set1") + scale_color_brewer(palette = "Set1") +
  labs(fill = "k-means\ncluster", color = "k-means\ncluster", shape = "k-means\ncluster")
```

Mean values for different element compositions in the clusters 1 to 4:

```{r elementsInGroups}
km_elements <- as_tibble(cbind(composition[, elements], cluster)) %>%
  group_by(kmeans) %>%
  summarize_all(mean) %>%
  mutate_at(vars(-kmeans), round, 4)

knitr::kable(km_elements, 
             rownames = FALSE, caption = "Mean values for element compositions")
```

```{r}
rm(list = c("km_elements"))
```

# Lead isotopes

```{r isotopes}
isotopes <- duchcov %>%
  select(id, starts_with("Pb2"))

isotopes <- bind_cols(isotopes, cluster)

DT::datatable(isotopes, rownames = FALSE)
```

```{r labels}
lab_206_207 <- labs(x = expression(paste(""^206, "Pb/", ""^204, "Pb")),
                    y = expression(paste(""^207, "Pb/", ""^204, "Pb")))
lab_206_208 <- labs(x = expression(paste(""^206, "Pb/", ""^204, "Pb")),
                    y = expression(paste(""^208, "Pb/", ""^204, "Pb")))
lab_207_208 <- labs(x = expression(paste(""^207, "Pb/", ""^206, "Pb")),
                    y = expression(paste(""^208, "Pb/", ""^206, "Pb")))
```


```{r kmiso, fig.cap="K-means clusters in isospace"}
ggplot(isotopes, aes(Pb206_204, Pb207_204)) +
  geom_point(aes(color = kmeans, shape = kmeans), size = 1.6) +
  scale_color_brewer(palette = "Set1", name = "k-means\ncluster") +
  labs(shape = "k-means\ncluster") + lab_206_207

ggplot(isotopes, aes(Pb206_204, Pb208_204)) +
  geom_point(aes(color = kmeans, shape = kmeans), size = 1.6) +
  scale_color_brewer(palette = "Set1", name = "k-means\ncluster") +
  labs(shape = "k-means\ncluster") + lab_206_208

ggplot(isotopes, aes(Pb207_206, Pb208_206)) +
  geom_point(aes(color = kmeans, shape = kmeans), size = 1.6) +
  scale_color_brewer(palette = "Set1", name = "k-means\ncluster") +
  labs(shape = "k-means\ncluster") + lab_207_208
```

```{r}
rm(list = c("plot_scree_clusters", "plot_sil_width"))
```

# Ore sources

Here we compare the distributions of Duchcov k-means clusters with distributions
of known sources based on lead isotopes.

```{r data-sources}
sources <- read_csv(here::here("data", "ore_sources.csv")) %>%
  mutate(Region = factor(Region,
                         levels = c("Valais", "Rheinland", "Saarland",
                                    "Rammelsberg & Harz",
                                    "E Alps", "SE Alps", "Erzgebirge", 
                                    "Slovakia", "E Carpathians")),
         Region2 = factor(Region2,
                          levels = c("Valais", "Rheinland", "Saarland",
                                     "Rammelsberg", "Harz",
                                     "E Alps", "SE Alps", "Erzgebirge", 
                                     "Slovakia", "E Carpathians")))

# frame margins of further plots
dist_duchcov <- vector(mode = "list")
dist_duchcov$Pb206x$min <-  min(isotopes$Pb206_204, na.rm = TRUE)
dist_duchcov$Pb206x$max <-  max(isotopes$Pb206_204, na.rm = TRUE)
dist_duchcov$Pb207y$min <-  min(isotopes$Pb207_204, na.rm = TRUE)
dist_duchcov$Pb207y$max <-  max(isotopes$Pb207_204, na.rm = TRUE)
dist_duchcov$Pb208_204y$min <-  min(isotopes$Pb208_204, na.rm = TRUE)
dist_duchcov$Pb208_204y$max <-  max(isotopes$Pb208_204, na.rm = TRUE)

dist_duchcov$Pb208y$min <-  min(isotopes$Pb208_206, na.rm = TRUE)
dist_duchcov$Pb208y$max <-  max(isotopes$Pb208_206, na.rm = TRUE)
dist_duchcov$Pb207x$min <-  min(isotopes$Pb207_206, na.rm = TRUE)
dist_duchcov$Pb207x$max <-  max(isotopes$Pb207_206, na.rm = TRUE)
```

Points removed as outliers are highlighted in red in the following figures.
Outliers are defined as points lying further than 2 interquartile ranges from the upper quartile of
the Mahalanobis distances from the data distribution center in a multidimensional space defined by
isotopic signals
$^{206}Pb/^{204}Pb$, $^{207}Pb/^{204}Pb$, $^{208}Pb/^{204}Pb$,
$^{207}Pb/^{206}Pb$ and $^{208}Pb/^{206}Pb$.

```{r sources-outliers, fig.width=10, fig.cap="Ore sources outliers"}
ggplot(sources, aes(Pb206_204, Pb207_204)) +
  geom_point(aes(color = Outlier), alpha = 0.4) +
  facet_wrap(~Region, scales = "free") +
  scale_color_manual(values = c("forestgreen", "red")) +
  lab_206_207

ggplot(sources, aes(Pb206_204, Pb208_204)) +
  geom_point(aes(color = Outlier), alpha = 0.4) +
  facet_wrap(~Region, scales = "free") +
  scale_color_manual(values = c("forestgreen", "red")) +
  lab_206_208

ggplot(sources, aes(Pb207_206, Pb208_206)) +
  geom_point(aes(color = Outlier), alpha = 0.4) +
  facet_wrap(~Region, scales = "free") +
  scale_color_manual(values = c("forestgreen", "red")) +
  lab_207_208
```

```{r remove-outliers}
sources <- sources %>% filter(Outlier == FALSE)
```

```{r gg-sources}
gg_206_207 <- ggplot(sources, aes(Pb206_204, Pb207_204)) +
  lab_206_207

gg_206_208 <- ggplot(sources, aes(Pb206_204, Pb208_204)) +
  lab_206_208

gg_207_208 <- ggplot(sources, aes(Pb207_206, Pb208_206)) +
  lab_207_208
```

Overall view of distributions of lead isotope values.

```{r isospaces-full, fig.cap="Ore sources overlayed with Duchcov hoard data"}
gg_206_207 +
  geom_point(alpha = 0.2, aes(color = Region)) +
  scale_color_viridis_d(direction = -1, end = 0.9) +
  annotate("rect",
           xmin = dist_duchcov$Pb206x$min, xmax = dist_duchcov$Pb206x$max,
           ymin = dist_duchcov$Pb207y$min, ymax = dist_duchcov$Pb207y$max, alpha = 0.2) +
  geom_point(data = isotopes, aes(Pb206_204, Pb207_204), shape = "cross")

gg_206_208 +
  geom_point(alpha = 0.2, aes(color = Region)) +
  scale_color_viridis_d(direction = -1, end = 0.9) +
  annotate("rect",
           xmin = dist_duchcov$Pb206x$min, xmax = dist_duchcov$Pb206x$max,
           ymin = dist_duchcov$Pb208_204y$min, ymax = dist_duchcov$Pb208_204y$max, alpha = 0.2) +
  geom_point(data = isotopes, aes(Pb206_204, Pb208_204), shape = "cross")

gg_207_208 +
  geom_point(alpha = 0.2, aes(color = Region)) +
  scale_color_viridis_d(direction = -1, end = 0.9) +
  annotate("rect",
           xmin = dist_duchcov$Pb207x$min, xmax = dist_duchcov$Pb207x$max,
           ymin = dist_duchcov$Pb208y$min, ymax = dist_duchcov$Pb208y$max, alpha = 0.2) +
  geom_point(data = isotopes, aes(Pb207_206, Pb208_206), shape = "cross")
```

```{r limited-gg-sources}
gg_206_207 <- gg_206_207 + 
  coord_cartesian(xlim = c(dist_duchcov$Pb206x$min, dist_duchcov$Pb206x$max),
                  ylim = c(dist_duchcov$Pb207y$min, dist_duchcov$Pb207y$max)) +
  guides(shape = guide_legend(ncol=2), color = guide_legend(ncol = 2)) +
  labs(shape = "K-means cluster")

gg_206_208 <- gg_206_208 + 
  coord_cartesian(xlim = c(dist_duchcov$Pb206x$min, dist_duchcov$Pb206x$max),
                  ylim = c(dist_duchcov$Pb208_204y$min, dist_duchcov$Pb208_204y$max)) +
  guides(shape = guide_legend(ncol=2), color = guide_legend(ncol = 2)) +
  labs(shape = "K-means cluster")

gg_207_208 <- gg_207_208 + 
  coord_cartesian(xlim = c(dist_duchcov$Pb207x$min, dist_duchcov$Pb207x$max),
                  ylim = c(dist_duchcov$Pb208y$min, dist_duchcov$Pb208y$max)) +
  guides(shape = guide_legend(ncol=2), color = guide_legend(ncol = 2)) +
  labs(shape = "K-means cluster")
```

Several visual methods are explored in order to determine whether the lead isotopic
signal from Duchcov hoard objects grouped by k-means clustering correspond to
known sources.
At first, *areas* corresponding to lead isotope signals from different geographic regions are
constructed in isospaces using concave hulls [@gombin2017, concaveman algorithm] of the point distributions 
for given geographic regions.

```{r sources-chull, fig.width = 10, fig.cap="Detail of ore sources highlighted using concave hulls overlayed with Duchcov data"}
# gg_206_207 +
#   geom_point(alpha = 0.2, aes(color = Region2), show.legend = FALSE) +
#   geom_mark_hull(aes(fill = Region2, color = Region2), expand = unit(2.4, "mm"),
#                  alpha = 0.1, show.legend = FALSE) +
#   scale_color_viridis_d(direction = -1, end = 0.9) + scale_fill_viridis_d(direction = -1) +
#   geom_point(data = isotopes, aes(shape = kmeans), alpha = 0.6) +
#   facet_wrap(~Region)
# 
# gg_206_208 +
#   geom_point(alpha = 0.2, aes(color = Region2), show.legend = FALSE) +
#   geom_mark_hull(aes(fill = Region2, color = Region2), expand = unit(2.4, "mm"),
#                  alpha = 0.1, show.legend = FALSE) +
#   scale_color_viridis_d(direction = -1, end = 0.9) + scale_fill_viridis_d(direction = -1) +
#   geom_point(data = isotopes, aes(shape = kmeans), alpha = 0.6) +
#   facet_wrap(~Region)
# 
# gg_207_208 +
#   geom_point(alpha = 0.2, aes(color = Region2), show.legend = FALSE) +
#   geom_mark_hull(aes(fill = Region2, color = Region2), expand = unit(2.4, "mm"),
#                  alpha = 0.1, show.legend = FALSE) +
#   scale_color_viridis_d(direction = -1, end = 0.9) + scale_fill_viridis_d(direction = -1) +
#   geom_point(data = isotopes, aes(shape = kmeans), alpha = 0.6) +
#   facet_wrap(~Region)
```

Kernel density estimation for each of the source regions helps in identifying to
what extent the point distribution of Duchcov hoard objects fits the density
distribution in given regions. `kde2d` algorithm of `MASS` package is used [@venables2002].

```{r sources-kde, fig.width = 10, fig.cap="Kernel density estimation of ore sources"}
gg_206_207 +
  stat_density2d(aes(fill = stat(nlevel)), geom = "polygon", alpha = 0.2, show.legend = FALSE) +
  scale_fill_gradient(low = "white", high = "black") +
  geom_point(alpha = 0.2, size = 0.2, color = "black") +
  geom_point(data = isotopes, aes(shape = kmeans, color = kmeans)) +
  scale_color_brewer(palette = "Set1", name = "K-means cluster") +
  facet_wrap(~ Region)

gg_206_208 +
  stat_density2d(aes(fill = stat(nlevel)), geom = "polygon", alpha = 0.2, show.legend = FALSE) +
  scale_fill_gradient(low = "white", high = "black") +
  geom_point(alpha = 0.2, size = 0.2, color = "black") +
  geom_point(data = isotopes, aes(shape = kmeans, color = kmeans)) +
  scale_color_brewer(palette = "Set1", name = "K-means cluster") +
  facet_wrap(~ Region)

gg_207_208 +
  stat_density2d(aes(fill = stat(nlevel)), geom = "polygon", alpha = 0.2, show.legend = FALSE) +
  scale_fill_gradient(low = "white", high = "black") +
  geom_point(alpha = 0.2, size = 0.2, color = "black") +
  geom_point(data = isotopes, aes(shape = kmeans, color = kmeans)) +
  scale_color_brewer(palette = "Set1", name = "K-means cluster") +
  facet_wrap(~ Region)
```

```{r}
rm(list = c("dist_duchcov"))
```

## Euclidean distances

Euclidean distance between all the points in given geographic region and k-means clusters
from Duchcov hoard is used as one of the proxies to identify possible sources
of the lead isotope ratios $^{208}Pb/^{204}Pb$, $^{207}Pb/^{204}Pb$, $^{206}Pb/^{204}Pb$,
$^{208}Pb/^{206}Pb$ and $^{207}Pb/^{206}Pb$.

The problem with using Euclidean distances is that the multivariate *shape* of the data distribution is
not taken into account, thus Mahalanobis distance (see further) seems as a better fit 
for the task, even though Euclidean distances are commonly used [e.g. @ling2014].

```{r distance-function}
nest_matrix <- function(df, gr) {
  output <- df %>% group_by(!!sym(gr)) %>%
    nest() %>% 
    mutate(mx = map(data, as.matrix))
  return(output)
}

point_cloud_distance <- function(origin, goal, group_origin, group_goal, method) {
  # create nested matrices
  x <- nest_matrix(origin, group_origin)
  y <- nest_matrix(goal, group_goal)
  lx <- nrow(x)
  ly <- nrow(y)
  # create empty list for results
  distance <- vector(mode = "list", length = ly)
  for (k in seq_along(distance)) {
    distance[[k]] <- vector(mode = "list", length = lx)
    names(distance[[k]]) <- x %>% pull(!!sym(group_origin))
  }
  names(distance) <- y %>% pull(!!sym(group_goal)) %>% str_c("K-means cluster ", .)
  # count euclidean distances
  if (method == "euclidean") {
    for (i in 1:ly) {
      for (j in 1:lx) {
        distance[[i]][[j]] <- pdist::pdist(X = y$mx[[i]], Y = x$mx[[j]])@dist
      }
      distance[[i]] <- bind_rows(lapply(distance[[i]], as_tibble), .id = "region")
    }
    # mahalanobis distance
  } else if (method == "mahalanobis") {
    for (i in 1:ly) {
      for (j in 1:lx) {
        distance[[i]][[j]] <- StatMatch::mahalanobis.dist(data.x = y$mx[[i]],
                                                          data.y = x$mx[[j]])
      }
      distance[[i]] <- bind_rows(
        lapply(lapply(distance[[i]], as.vector), as_tibble), .id = "region")
    }
  }
  distance <- bind_rows(distance, .id = "kmeans")
  return(distance)
}
```


```{r euclidean-distance}
src <- sources %>% select(Region2, starts_with("Pb"))
iso <- isotopes %>% select(kmeans, starts_with("Pb")) %>% na.omit()

euclidean_distance <- point_cloud_distance(origin = src, goal = iso, 
                                           group_origin = "Region2", group_goal = "kmeans",
                                           method = "euclidean") %>% 
  mutate(region = fct_relevel(region, levels(sources$Region2)))
```

```{r euclidean-boxplot, fig.width=10, fig.cap="Euclidean distances between Duchcov k-means clusters and different regions"}
# ggplot(euclidean_distance, aes(y = region, x = value, fill = region)) +
#   ggridges::geom_density_ridges(alpha = 0.4, show.legend = FALSE, scale = 1.1) +
#   scale_fill_viridis_d(direction = -1, end = 0.9) +
#   coord_cartesian(xlim = c(0, 1)) +
#   facet_wrap(~kmeans, scales = "fixed") +
#   labs(y = "Region",
#        x = "Euclidean distance to a given Duchcov K-means cluster (x axis limited to interval 0 - 1)")
```

## Mahalanobis distances

Mahalanobis distance is used as a metric to compare points fit in a given source distribution.
The scale differences and effects of correlation between the variables are removed in case of Mahalanobis distance.

```{r mahalanobis-distance}
mahalanobis_distance <- point_cloud_distance(origin = src, goal = iso, 
                                             group_origin = "Region2", group_goal = "kmeans",
                                             method = "mahalanobis") %>% 
  mutate(region = fct_relevel(region, levels(sources$Region2)))
```


```{r mahalanobis-boxplot, fig.width=10, fig.cap="Mahalanobis distances between Duchcov k-means clusters and different regions"}
# ggplot(mahalanobis_distance, aes(y = region, x = value, fill = region)) +
#   ggridges::geom_density_ridges(alpha = 0.4, show.legend = FALSE, scale = 1.1) +
#   scale_fill_viridis_d(direction = -1, end = 0.9) +
#   coord_cartesian(xlim = c(0, 10)) +
#   facet_wrap(~kmeans, scales = "fixed") +
#   labs(y = "Region",
#        x = "Mahalanobis distance to a given Duchcov K-means cluster (x axis limited to interval 0 - 10)")
```

```{r}
rm(list = c("iso", "src", "nest_matrix", "point_cloud_distance"))
```

## Discriminant analysis

Manova is used in order to determine whether there are significant differences
between group means for the distinct regions.

```{r lm}
sources_lm <- lm(as.matrix(sources[, c("Pb207_206", "Pb208_206",
                                       "Pb206_204", "Pb207_204", "Pb208_204")]) ~ sources$Region2)

summary(sources_lm)

summary(manova(sources_lm), test = "Pillai")
# summary(manova(sources_lm), test = "Wilks")
# summary(manova(sources_lm), test = "Roy")
# summary(manova(sources_lm), test = "Hotelling-Lawley")
```

Linear discriminant analysis is then used to separate the regions.

```{r lda}
n_levels_sources <- length(levels(sources$Region2))

sources_lda <- MASS::lda(Region2 ~ ., sources[, c("Region2", 
                                                  "Pb207_206", "Pb208_206", 
                                                  "Pb206_204", "Pb207_204", "Pb208_204")],
                         prior = as.double(
                           paste(
                             rep(1/n_levels_sources, 
                                 n_levels_sources), sep = ",")))
sources_lda
```

Using the LDA to predict the regions of original points, we get a lot of error, see the confusion matrix below.
How to read it: rows are the regions the point is from and columns are regions predicted
based on the LDA.

```{r confusion-matrix}
sources_pred <- predict(sources_lda)
prediction <- with(sources_pred, data.frame(Region = sources$Region2,
                                            Predict = class, round(posterior, 2)))

knitr::kable(addmargins(xtabs(~fct_drop(Region) + fct_drop(Predict), prediction)), 
             caption = "Confusion matrix")

# overall success of the model in predicting correct region
round(mean(prediction$Region == prediction$Predict), 2)

# individual correct predictions (diagonal)
round(prop.table(table(droplevels(prediction$Region),
                       droplevels(prediction$Predict)),
                 margin = 1), 2)
```

Prediction of Regions based on data on points from Duchcov hoard.

```{r duchcov-prediction}
duchcov_prediction <- predict(object = sources_lda, newdata = isotopes[, -7])
duchcov_prediction_df <- with(duchcov_prediction,
                              data.frame(id = isotopes[, "id"],
                                         kmeans = isotopes[, "kmeans"],
                                         predicted_region = class,
                                         round(posterior, 2)))

# posterior probabilities of individual predictions
DT::datatable(duchcov_prediction_df,
              caption = "Posterior probabilities of predicted sources")

duchcov_prediction_df %>% 
  select(-predicted_region) %>% 
  gather(key = "region", value = "probability", -id, -kmeans) %>% 
  group_by(kmeans, region) %>% 
  dplyr::summarize(mean_prob = mean(probability, na.rm = TRUE)) %>% 
  ggplot(aes(x = region, y = mean_prob)) +
  geom_col(fill = "white", col = "black") +
  facet_wrap(~kmeans, ncol = 1) +
  labs(x = "Region", y = "Mean posterior probability")
```

```{r duchcov-prediction-counts}
# matrix of counts of points in individual k-means clusters (rows)
# fitting to various regions (columns)
knitr::kable(addmargins(xtabs(~kmeans + fct_drop(predicted_region),
                              duchcov_prediction_df)), 
             caption = "Counts of points per different sources")
```

```{r predicted-mapped, fig.cap="Source regions as assigned to Duchcov k-means clusters (numeric labels) by LDA"}
ggplot(isotopes, aes(Pb206_204, Pb207_204, label = kmeans)) +
  geom_text(aes(color = duchcov_prediction_df$predicted_region, 
                shape = duchcov_prediction_df$predicted_region)) +
  scale_color_brewer(palette = "Set1", name = "predicted\nregion") +
  labs(shape = "predicted\nregion") + lab_206_207

ggplot(isotopes, aes(Pb206_204, Pb208_204, label = kmeans)) +
  geom_text(aes(color = duchcov_prediction_df$predicted_region, 
                shape = duchcov_prediction_df$predicted_region)) +
  scale_color_brewer(palette = "Set1", name = "predicted\nregion") +
  labs(shape = "predicted\nregion") + lab_206_208

ggplot(isotopes, aes(Pb207_206, Pb208_206, label = kmeans)) +
  geom_text(aes(color = duchcov_prediction_df$predicted_region, 
                shape = duchcov_prediction_df$predicted_region)) +
  scale_color_brewer(palette = "Set1", name = "predicted\nregion") +
  labs(shape = "predicted\nregion") + lab_207_208
```

```{r clean-envir}
rm(list = c("med_d_all", "med_d_regions", 
            "euclidean_distance", "mahalanobis_distance",
            "filtered_regions", "sources_subset", 
            "sources_lm", "sources_lda", "sources_pred",
            "n_levels_sources", "prediction",
            "duchcov_prediction", "duchcov_prediction_df"))
```


# Burial grounds

```{r data-burials}
burials <- read_csv(here::here("data", "burial_grounds.csv"))
```

```{r brooch}
duchcov <- duchcov %>% transmute(brooch = if_else(str_detect(type_eng, "^brooch_"),
                                                  "brooch", "not brooch"),
                                 brooch = factor(brooch, levels = c("brooch", "not brooch")),
                                 id = id) %>%
  left_join(isotopes)

burials <- burials %>% mutate(brooch = if_else(str_detect(type_eng, "brooch_"),
                                               "brooch", "not brooch"),
                              brooch = factor(brooch, levels = c("brooch", "not brooch"))) %>% 
  select(-type_eng)
```

```{r burials-gg}
g_bur_206_207 <- ggplot(burials, aes(Pb206_204, Pb207_204)) +
  labs(color = "Burials", shape = "Duchcov k-means\ncluster") +
  lab_206_207 +
  theme(legend.position = c(0.84, 0.2)) +
  guides(shape = guide_legend(ncol=2), color = guide_legend(ncol = 2))
g_bur_206_208 <- ggplot(burials, aes(Pb206_204, Pb208_204)) +
  labs(color = "Burials", shape = "Duchcov k-means\ncluster") +
  lab_206_208 +
  theme(legend.position = c(0.84, 0.2)) +
  guides(shape = guide_legend(ncol=2), color = guide_legend(ncol = 2))
g_bur_207_208 <- ggplot(burials, aes(Pb207_206, Pb208_206)) +
  labs(color = "Burials", shape = "Duchcov k-means\ncluster") +
  lab_207_208 +
  theme(legend.position = c(0.84, 0.2)) +
  guides(shape = guide_legend(ncol=2), color = guide_legend(ncol = 2))
```

## Convex hulls of isotope signals of artefacts from burials

```{r burials, fig.cap="Distribution of data from different burials (LTB1 horizon) overlayed with Duchcov hoard"}
g_bur_206_207 + geom_point(aes(color = site), alpha = 0.8, show.legend = FALSE) +
  geom_mark_hull(aes(color = site, fill = site), expand = unit(2.4, "mm"),
                 alpha = 0.1, show.legend = FALSE) +
  scale_color_brewer(palette = "Set1") + scale_fill_brewer(palette = "Set1") +
  geom_point(data = duchcov, aes(shape = kmeans), size = 2, alpha = 0.4) +
  facet_wrap(~site)

g_bur_206_208 + geom_point(aes(color = site), alpha = 0.8, show.legend = FALSE) +
  geom_mark_hull(aes(color = site, fill = site), expand = unit(2.4, "mm"),
                 alpha = 0.1, show.legend = FALSE) +
  scale_color_brewer(palette = "Set1") + scale_fill_brewer(palette = "Set1") +
  geom_point(data = duchcov, aes(shape = kmeans), size = 2, alpha = 0.4) +
  facet_wrap(~site)

g_bur_207_208 + geom_point(aes(color = site), alpha = 0.8, show.legend = FALSE) +
  geom_mark_hull(aes(color = site, fill = site), expand = unit(2.4, "mm"),
                 alpha = 0.1, show.legend = FALSE) +
  scale_color_brewer(palette = "Set1") + scale_fill_brewer(palette = "Set1") +
  geom_point(data = duchcov, aes(shape = kmeans), size = 2, alpha = 0.4) +
  facet_wrap(~site)
```

## Kernel density estimates

```{r kde-burials, fig.cap="KDE of data from different burials overlayed with Duchcov hoard"}
# g_bur_206_207 +
#   stat_density2d(aes(fill = stat(nlevel)), geom = "polygon", alpha = 0.2, show.legend = FALSE) +
#   scale_fill_gradient(low = "white", high = "black") +
#   scale_color_brewer(palette = "Set1") +
#   geom_point(aes(color = site), alpha = 0.8, show.legend = FALSE) +
#   geom_point(data = duchcov, aes(shape = kmeans), size = 1.4, alpha = 0.4) +
#   facet_wrap(~site)
# 
# g_bur_206_208 +
#   stat_density2d(aes(fill = stat(nlevel)), geom = "polygon", alpha = 0.2, show.legend = FALSE) +
#   scale_fill_gradient(low = "white", high = "black") +
#   scale_color_brewer(palette = "Set1") +
#   geom_point(aes(color = site), alpha = 0.8, show.legend = FALSE) +
#   geom_point(data = duchcov, aes(shape = kmeans), size = 1.4, alpha = 0.4) +
#   facet_wrap(~site)
# 
# g_bur_207_208 +
#   stat_density2d(aes(fill = stat(nlevel)), geom = "polygon", alpha = 0.2, show.legend = FALSE) +
#   scale_fill_gradient(low = "white", high = "black") +
#   scale_color_brewer(palette = "Set1") +
#   geom_point(aes(color = site), alpha = 0.8, show.legend = FALSE) +
#   geom_point(data = duchcov, aes(shape = kmeans), size = 1.4, alpha = 0.4) +
#   facet_wrap(~site)
```


## Density distributions of burials and Duchcov hoard artefacts

```{r}
library(cowplot)
```

```{r bind-duchcov-burials}
origin <- bind_rows(duchcov = duchcov[, c("Pb207_204", "Pb206_204", 
                                          "Pb208_204", "Pb208_206", 
                                          "Pb207_206", "brooch")],
                    burials = burials[, c("Pb207_204", "Pb206_204", 
                                          "Pb208_204", "Pb208_206", 
                                          "Pb207_206", "brooch")],
                    .id = "origin")
```

<!--
```{r density206-207, fig.cap="Density distribution of burial finds and Duchcov hoard"}
pmain206_207 <- ggplot(origin, aes(Pb206_204, Pb207_204, color = origin)) +
stat_density2d(show.legend = FALSE, alpha = 0.4) +
geom_point(size = 2, alpha = 0.4) +
scale_color_brewer(palette = "Set1") +
labs(color = "Origin") + lab_206_207

ydens206_207 <- axis_canvas(pmain206_207, axis = "y", coord_flip = TRUE) +
geom_density(data = origin, aes(x = Pb207_204, fill = origin),
alpha = 0.2, size = 0.2)+
coord_flip() +
scale_fill_brewer(palette = "Set1")

xdens206_207 <- axis_canvas(pmain206_207, axis = "x", coord_flip = FALSE) +
geom_density(data = origin, aes(x = Pb206_204, fill = origin),
alpha = 0.2, size = 0.2) +
scale_fill_brewer(palette = "Set1")

pfinal206_207 <- insert_yaxis_grob(pmain206_207, ydens206_207, 
grid::unit(.2, "null"), position = "right")
pfinal206_207 <- insert_xaxis_grob(pfinal206_207, xdens206_207, 
grid::unit(.2, "null"), position = "top")

ggdraw(pfinal206_207)
```

```{r density206-208, fig.cap="Density distribution of burial finds and Duchcov hoard"}
pmain206_208 <- ggplot(origin, aes(Pb206_204, Pb208_204, color = origin)) +
stat_density2d(show.legend = FALSE, alpha = 0.4) +
geom_point(size = 2, alpha = 0.4) +
scale_color_brewer(palette = "Set1") +
labs(color = "Origin") + lab_206_208

ydens206_208 <- axis_canvas(pmain206_208, axis = "y", coord_flip = TRUE) +
geom_density(data = origin, aes(x = Pb208_204, fill = origin),
alpha = 0.2, size = 0.2)+
coord_flip() +
scale_fill_brewer(palette = "Set1")

xdens206_208 <- axis_canvas(pmain206_208, axis = "x", coord_flip = FALSE) +
geom_density(data = origin, aes(x = Pb206_204, fill = origin),
alpha = 0.2, size = 0.2) +
scale_fill_brewer(palette = "Set1")

pfinal206_208 <- insert_yaxis_grob(pmain206_208, ydens206_208, 
grid::unit(.2, "null"), position = "right")
pfinal206_208 <- insert_xaxis_grob(pfinal206_208, xdens206_208, 
grid::unit(.2, "null"), position = "top")

ggdraw(pfinal206_208)
```

```{r density207-208, fig.cap="Density distribution of burial finds and Duchcov hoard"}
pmain207_208 <- ggplot(origin, aes(Pb207_206, Pb208_206, color = origin)) +
stat_density2d(show.legend = FALSE, alpha = 0.4) +
geom_point(size = 2, alpha = 0.4) +
scale_color_brewer(palette = "Set1") +
labs(color = "Origin") + lab_207_208

ydens207_208 <- axis_canvas(pmain207_208, axis = "y", coord_flip = TRUE) +
geom_density(data = origin, aes(x = Pb208_206, fill = origin),
alpha = 0.2, size = 0.2)+
coord_flip() +
scale_fill_brewer(palette = "Set1")

xdens207_208 <- axis_canvas(pmain207_208, axis = "x", coord_flip = FALSE) +
geom_density(data = origin, aes(x = Pb207_206, fill = origin),
alpha = 0.2, size = 0.2) +
scale_fill_brewer(palette = "Set1")

pfinal207_208 <- insert_yaxis_grob(pmain207_208, ydens207_208, 
grid::unit(.2, "null"), position = "right")
pfinal207_208 <- insert_xaxis_grob(pfinal207_208, xdens207_208, 
grid::unit(.2, "null"), position = "top")

ggdraw(pfinal207_208)
```
-->

## Distribution of brooches

```{r brooches-gg}
g_bro_206_207 <- ggplot(origin, aes(Pb206_204, Pb207_204, color = origin)) +
  facet_wrap(~ brooch) +
  labs(color = "Origin") +
  lab_206_207
g_bro_206_208 <- ggplot(origin, aes(Pb206_204, Pb208_204, color = origin)) +
  labs(color = "Origin") +
  facet_wrap(~ brooch) +
  lab_206_208
g_bro_207_208 <- ggplot(origin, aes(Pb207_206, Pb208_206, color = origin)) +
  labs(color = "Origin") +
  facet_wrap(~ brooch) +
  lab_207_208
```

```{r brooch-plots, fig.cap="Distribution of brooches and other artefact types in burials and Duchcov hoard"}
g_bro_206_207 +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)

g_bro_206_208 +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)

g_bro_207_208 +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)
```

# References

